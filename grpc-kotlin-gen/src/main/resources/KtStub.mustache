{{#packageName}}
package {{packageName}}
{{/packageName}}

import {{packageName}}.{{serviceName}}Grpc.*

import io.grpc.BindableService
import io.grpc.CallOptions
import io.grpc.Channel
import io.grpc.ServerServiceDefinition
import io.grpc.stub.AbstractStub
import io.grpc.stub.ServerCalls
import io.grpc.stub.StreamObserver

import kotlinx.coroutines.experimental.async
import kotlinx.coroutines.experimental.launch
import kotlinx.coroutines.experimental.CompletableDeferred
import kotlinx.coroutines.experimental.Deferred
import kotlinx.coroutines.experimental.GlobalScope
import kotlinx.coroutines.experimental.channels.Channel as KtChannel
import kotlinx.coroutines.experimental.channels.ReceiveChannel
import kotlinx.coroutines.experimental.channels.SendChannel
import kotlinx.coroutines.experimental.runBlocking

{{#deprecated}}@Deprecated("deprecated"){{/deprecated}}
@javax.annotation.Generated(
    value = ["by gRPC Kotlin generator"],
    comments = "Source: {{protoName}}")
object {{className}} {

  /**
   * Creates a new coroutine stub that supports all call types for the service
   */
  @JvmStatic
  fun newStub(channel: Channel): {{serviceName}}KtStub {
    return {{serviceName}}KtStub(channel)
  }

  class {{serviceName}}KtStub : AbstractStub<{{serviceName}}KtStub> {

    private val delegate: {{packageName}}.{{serviceName}}Grpc.{{serviceName}}Stub

    internal constructor(channel: Channel) : super(channel) {
      delegate = {{packageName}}.{{serviceName}}Grpc.newStub(channel)
    }

    internal constructor(channel: Channel, callOptions: CallOptions) : super(channel, callOptions) {
      delegate = {{packageName}}.{{serviceName}}Grpc.newStub(channel).build(channel, callOptions)
    }

    override fun build(channel: Channel, callOptions: CallOptions): {{serviceName}}KtStub {
      return {{serviceName}}KtStub(channel, callOptions)
    }

    {{#methods}}
    {{#javaDoc}}{{{javaDoc}}}{{/javaDoc}}
    {{#deprecated}}@Deprecated("deprecated"){{/deprecated}}
    {{#isManyInput}}
    {{#isManyOutput}}
    {{! Many input many outpout}}
    suspend fun {{methodName}}(): ManyToManyCall<{{inputType}}, {{outputType}}> {
      val responseChannel = StreamObserverChannel<{{outputType}}>()
      val requestObserver = delegate.{{methodName}}(responseChannel)
      val requestChannel = KtChannel<{{inputType}}>(KtChannel.UNLIMITED)
      connectChannelToObserver(requestChannel, requestObserver)
      return ManyToManyCall(requestChannel, responseChannel)
    }
    {{/isManyOutput}}
    {{^isManyOutput}}
    {{! Many input single output}}
    suspend fun {{methodName}}(): ManyToOneCall<{{inputType}}, {{outputType}}> {
      val responseDeferred = StreamObserverDeferred<{{outputType}}>()
      val requestObserver = delegate.{{methodName}}(responseDeferred)
      val requestChannel = KtChannel<{{inputType}}>(KtChannel.UNLIMITED)
      connectChannelToObserver(requestChannel, requestObserver)
      return ManyToOneCall(requestChannel, responseDeferred)
    }
    {{/isManyOutput}}
    {{/isManyInput}}
    {{^isManyInput}}
    {{#isManyOutput}}
    {{! Single input many outout}}
    suspend fun {{methodName}}(request: {{inputType}}): ReceiveChannel<{{outputType}}> {
      val responseChannel = StreamObserverChannel<{{outputType}}>()
      delegate.{{methodName}}(request, responseChannel)
      return responseChannel
    }
    {{/isManyOutput}}
    {{^isManyOutput}}
    {{! Single input single outout}}
    suspend fun {{methodName}}(request: {{inputType}}): {{outputType}} {
      val responseDeferred = StreamObserverDeferred<{{outputType}}>()
      delegate.{{methodName}}(request, responseDeferred)
      return responseDeferred.await()
    }
    {{/isManyOutput}}
    {{/isManyInput}}

    {{/methods}}
  }

  {{#javaDoc}}{{{javaDoc}}}{{/javaDoc}}
  abstract class {{serviceName}}ImplBase : BindableService {

    {{#methods}}
    {{#javaDoc}}{{{javaDoc}}}{{/javaDoc}}
    {{#deprecated}}@Deprecated("deprecated"){{/deprecated}}
    {{#isManyInput}}
    {{#isManyOutput}}
    {{! Many input many outpout}}
    open suspend fun {{methodName}}(requestChannel: ReceiveChannel<{{inputType}}>): ReceiveChannel<{{outputType}}> {
      throw io.grpc.StatusRuntimeException(io.grpc.Status.UNIMPLEMENTED)
    }

    internal suspend fun {{methodName}}Internal(responseObserver: StreamObserver<{{outputType}}>): StreamObserver<{{inputType}}> {
      val requestChannel = StreamObserverChannel<{{inputType}}>()
      val responseChannel = {{methodName}}(requestChannel)
      connectChannelToObserver(responseChannel, responseObserver)
      return requestChannel
    }
    {{/isManyOutput}}
    {{^isManyOutput}}
    {{! Many input single output}}
    open suspend fun {{methodName}}(requestChannel: ReceiveChannel<{{inputType}}>): {{outputType}} {
      throw io.grpc.StatusRuntimeException(io.grpc.Status.UNIMPLEMENTED)
    }

    internal suspend fun {{methodName}}Internal(responseObserver: StreamObserver<{{outputType}}>): StreamObserver<{{inputType}}> {
      val requestChannel = StreamObserverChannel<{{inputType}}>()
      val responseDeferred = GlobalScope.async { {{methodName}}(requestChannel) }
      connectDeferredToObserver(responseDeferred, responseObserver)
      return requestChannel
    }
    {{/isManyOutput}}
    {{/isManyInput}}
    {{^isManyInput}}
    {{#isManyOutput}}
    {{! Single input many outout}}
    open suspend fun {{methodName}}(request: {{inputType}}): ReceiveChannel<{{outputType}}> {
      throw io.grpc.StatusRuntimeException(io.grpc.Status.UNIMPLEMENTED)
    }

    internal suspend fun {{methodName}}Internal(request: {{inputType}}, responseObserver: StreamObserver<{{outputType}}>) {
      val responseChannel = {{methodName}}(request)
      connectChannelToObserver(responseChannel, responseObserver)
    }
    {{/isManyOutput}}
    {{^isManyOutput}}
    {{! Single input single outout}}
    open suspend fun {{methodName}}(request: {{inputType}}): {{outputType}} {
      throw io.grpc.StatusRuntimeException(io.grpc.Status.UNIMPLEMENTED)
    }

    internal suspend fun {{methodName}}Internal(request: {{inputType}}, responseObserver: StreamObserver<{{outputType}}>) {
      val responseDeferred = GlobalScope.async { {{methodName}}(request) }
      connectDeferredToObserver(responseDeferred, responseObserver)
    }
    {{/isManyOutput}}
    {{/isManyInput}}

    {{/methods}}
    override fun bindService(): ServerServiceDefinition {
      return ServerServiceDefinition.builder(getServiceDescriptor())
          {{#methods}}
          .addMethod(
              get{{methodNamePascalCase}}Method(),
              ServerCalls.{{grpcCallsMethodName}}(
                  MethodHandlers(this, METHODID_{{methodNameUpperUnderscore}})))
          {{/methods}}
          .build()
    }
  }

  private suspend fun <E> connectChannelToObserver(channel: ReceiveChannel<E>, observer: StreamObserver<E>) {
    GlobalScope.launch {
      for (value in channel) {
        observer.onNext(value)
      }
      observer.onCompleted()
    }
  }

  private suspend fun <E> connectDeferredToObserver(deferred: Deferred<E>, observer: StreamObserver<E>) {
    GlobalScope.launch {
      observer.onNext(deferred.await())
      observer.onCompleted()
    }
  }

  data class ManyToOneCall<in TRequest, out TResponse>(
      val request: SendChannel<TRequest>,
      val response: Deferred<TResponse>)

  data class ManyToManyCall<in TRequest, out TResponse>(
      val request: SendChannel<TRequest>,
      val response: ReceiveChannel<TResponse>)

  private class StreamObserverDeferred<E>
    : StreamObserver<E>,
      CompletableDeferred<E> by CompletableDeferred() {
    override fun onNext(value: E) { complete(value) }
    override fun onError(t: Throwable) { cancel(t) }
    override fun onCompleted() { /* nothing */ }
  }

  private class StreamObserverChannel<E>
    : KtChannel<E> by KtChannel<E>(KtChannel.UNLIMITED),
      StreamObserver<E> {
    override fun onNext(value: E) { offer(value) }
    override fun onError(t: Throwable?) { close(cause = t) }
    override fun onCompleted() { close(cause = null) }
  }

  {{#methods}}
  val METHODID_{{methodNameUpperUnderscore}} = {{methodNumber}}
  {{/methods}}

  private class MethodHandlers<Req, Resp> internal constructor(
      private val serviceImpl: {{serviceName}}ImplBase,
      private val methodId: Int
  ) : ServerCalls.UnaryMethod<Req, Resp>,
      ServerCalls.ServerStreamingMethod<Req, Resp>,
      ServerCalls.ClientStreamingMethod<Req, Resp>,
      ServerCalls.BidiStreamingMethod<Req, Resp> {


    @Suppress("UNCHECKED_CAST")
    override fun invoke(request: Req, responseObserver: StreamObserver<Resp>) = when (methodId) {
      {{#methods}}
      {{^isManyInput}}
      METHODID_{{methodNameUpperUnderscore}} -> runBlocking {
          serviceImpl.{{methodName}}Internal(
              request as {{inputType}},
              responseObserver as StreamObserver<{{outputType}}>
          )
      }
      {{/isManyInput}}
      {{/methods}}
      else -> throw AssertionError()
    }

    @Suppress("UNCHECKED_CAST")
    override fun invoke(responseObserver: StreamObserver<Resp>) = when (methodId) {
      {{#methods}}
      {{#isManyInput}}
      METHODID_{{methodNameUpperUnderscore}} -> runBlocking {
          serviceImpl.{{methodName}}Internal(
              responseObserver as StreamObserver<{{outputType}}>
          ) as StreamObserver<Req>
      }
      {{/isManyInput}}
      {{/methods}}
      else -> throw AssertionError()
    }
  }
}
